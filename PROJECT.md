# Тестирование и верификация смарт-контрактов

[Ссылка на описание проекта на сайте ВШЭ](http://wiki.cs.hse.ru/Тестирование_и_верификация_смарт-контрактов_(проект))

## Введение

Ближе к концу 2017 года и началу 2018 понятие «блокчейн» (англ. blockchain - цепочка блоков) можно было слышать чуть ли не из любой IT-компании. Что это вообще такое? Это модель распределённой сети, [первая статья](https://bitcoin.org/bitcoin.pdf) про которую была опубликована в 2008 годы под авторством некого Satoshi Nakamoto (возможно, это группа людей, это всё ещё неизвестно).

Основным признаком блокчейн сети является распределённость хранения т.н. блоков на всех участниках сети, а так же подтверждение легитимности блока большинством участников сети. Каждый блок хранит в себе хэш предыдущего (первый блок создаётся со случайным хэшем вместо хэша предыдущего блока). Такая распределённая сеть сразу накладывает ограничения на количество данных, которые можно передавать в секунду (сеть Bitcoin умеет обрабатывать 2-3 транзакции в секунду, сеть Ethereum около 20). Кроме того, такой подход даёт и интересные преимущества: все кошельки и транзакции полностью анонимны (не содержат персональных данных участников), все участники сети видят всё, что происходит в сети, а так же транзация не может быть удалена из сети, так как для этого нужно удалить её у всех участников сети.

В 2015 году появилась платформа [Ethereum](https://ethereum.org/), позволяющая загружать в сеть не просто транзации, а т.н. смарт-контракты (код, написанный на специальном тьюринг-полном языке Solidity или немного изменённый ASM), написанные для Ethereum Virtual Machine. Код выполняется на одной из нод, а другие проверяют результат вычислений. За каждый вызов функции контрака вызывающий должен заплатить, потому что надо же что-то заплатить майнеру.

Поскольку смарт-контракт нельзя удалить из сети, к вопросу его тестирования надо подходить с особой ответственностью. Тестирование и является основной темой этого проекта. После анализа ряда существующих решений и каких-то более-менее осуществимых идей мы пришли к динамическому тестированию с симуляцией сети, о чём и пойдёт речь дальше.

## Проблема тестирования и верификации

Но сначала более подробно остановимся на проблеме и немного расскажем про существующие решения.

> Надо дописать этот раздел.

## Постановка задачи

Имеется смарт-контракт, хочется за разумное время (не более нескольких часов) проводить какое-то автоматическое тестирование для отлавливания проблем в коде. Потенциально хочется угадывать места различных атак, которые могут привести к неправильному поведению экономики / других характеристик контракта.

## Исследование и идеи

Наверное, писать как мы изучали технологии (блокчейны Bitcoin и Ethereum) и JavaScript (хотя это было неприятно) и интерфейсы Geth не стоит. Сразу к сути.

Сначала мы посмотрели на код на Solidity и подумали, что в принципе можно разобрать код синтаксически и работать с ним на уровне синтаксического дерева. Тогда можно перебирать значения глобальных переменных контракта и смотреть на то, как ведут себя функции. Так можно делать перебор по дереву вариантов значений с отсечениями, например, или случайные последовательности смотреть. Можно исследовать пути в дереве вариантов значений и многое другое. Однако, в этот момент мы подумали о том, что вообще-то EVM делает за нас всю работу. Можно запихать контракт в неё и моделировать систему динамически.

В этот момент начало вырисовываться что-то более реальное.

### Финальная модель системы

Нам нужно динамически моделировать несколько нод-участников блокчейна и уметь ими управлять централизованно. Понятно, что код на нодах должен как-то уметь пользоваться Geth (нормальные библиотеки которого есть только под JS),поэтому код на ноде должен быть написан на JavaScript.

Теперь надо придумать, как управлять нодами. Давайте воспользуемсяя какой-нибудь системой обмена сообщениями, например, RabbitMQ. Написанный код для обмена можно найти в ветке `f/rabbit_communication`. После этого мы сели и подумали, а что мы вообще написали. Выяснилось, что мы попытались реализовать Celery (известная реализация распределённой очереди задач для Python). Поскольку мы итак писали на Python, то мы решили просто воспользоваться Celery.
